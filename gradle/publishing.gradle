// ========================================
// PUBLISHING TASKS
// ========================================

tasks.register("#publishNewVersion") {
    group = "publishing"
    description = "Publish to both Modrinth and CurseForge"

    dependsOn "build", "modrinth", "publishCurseForge", "archiveChangelog", "updateVersionsJson" //,"publishToMavenLocal"

    doLast {
        println "=== Publish Completed ==="
        println "Mod Version: ${mod_version}"
        println "Minecraft Version: ${minecraft_version}"
        println "Published to Modrinth and CurseForge"
        println "Updated versions.json with current version"
    }
}

tasks.register("#publishModrinthOnly") {
    group = "publishing"
    description = "Publish only to Modrinth"

    dependsOn "build", "modrinth", "updateVersionsJson"

    doLast {
        println "=== Modrinth Publish Completed ==="
        println "Mod Version: ${mod_version}"
        println "Published to Modrinth only"
        println "Updated versions.json with current version"
    }
}

tasks.register("#publishCurseForgeOnly") {
    group = "publishing"
    description = "Publish only to CurseForge"

    dependsOn "build", "publishCurseForge", "updateVersionsJson"

    doLast {
        println "=== CurseForge Publish Completed ==="
        println "Mod Version: ${mod_version}"
        println "Published to CurseForge only"
        println "Updated versions.json with current version"
    }
}

tasks.register("dryRunPublish") {
    group = "publishing"
    description = "Dry run - shows what would be published without actually publishing"

    doLast {
        println "=== DRY RUN - PUBLISH PREVIEW ==="
        println "Mod ID: ${mod_id}"
        println "Mod Name: ${mod_name}"
        println "Mod Version: ${mod_version}"
        println "Minecraft Version: ${minecraft_version}"
        println "Release Type: ${release_type}"
        println "Game Versions: ${project.findProperty("game_versions")}"
        println ""
        println "Modrinth Project ID: ${mr_id}"
        println "CurseForge Project ID: ${project.findProperty("cf_id")}"
        println ""
        println "JAR File: ${jar.archiveFileName.get()}"
        println "JAR Path: ${jar.destinationDirectory.get()}/${jar.archiveFileName.get()}"
        println ""

        def changelogContent = generateLatestChangelog()
        println "Changelog Preview:"
        println "==================="
        println changelogContent.take(500) + (changelogContent.length() > 500 ? "..." : "")
        println "==================="
        println ""

        println "versions.json changes that would be made:"
        def currentVersion = mod_version
        def currentMcVersion = minecraft_version
        println "  ${currentMcVersion}-latest: ${currentVersion}"
        println "  ${currentMcVersion}-recommended: ${currentVersion}"
        println ""

        println "Environment Variables:"
        println "MODRINTH_TOKEN: ${System.getenv("MODRINTH_TOKEN") ? 'SET' : 'NOT SET'}"
        println "CURSEFORGE_TOKEN: ${System.getenv("CURSEFORGE_TOKEN") ? 'SET' : 'NOT SET'}"
    }
}

ext.validateTokens = {
    def modrinthToken = System.getenv("MODRINTH_TOKEN") ?: project.findProperty("modrinthToken")?.toString()
    def cfToken = System.getenv("CURSEFORGE_TOKEN") ?: project.findProperty("curseforgeToken")?.toString()

    if (modrinthToken == null) {
        throw new GradleException("Missing MODRINTH_TOKEN: set it either as ENV (MODRINTH_TOKEN) or in ~/.gradle/gradle.properties (modrinthToken)")
    }

    if (cfToken == null) {
        throw new GradleException("Missing CURSEFORGE_TOKEN: set it either as ENV (CURSEFORGE_TOKEN) or in ~/.gradle/gradle.properties (curseforgeToken)")
    }

    return [modrinthToken, cfToken]
}

// Read Gradle properties
def modVersion = project.findProperty('mod_version')?.toString() ?: '0.0.0'
def gameVersions = (project.findProperty('game_versions')?.toString() ?: '')
        .split(',')
        .collect { it.trim() }
        .findAll { it }
def releaseType = project.findProperty('release_type')?.toString()?.trim()?.toLowerCase() ?: 'stable'
def onlyLatest = ['alpha', 'beta'].contains(releaseType)

tasks.register('updateVersionsJson') {
    group = 'publishing'
    description = 'Update versions.json and sync it to every existing remote branch on origin without rewriting remote history. Outputs and comments in English.'

    doLast {
        // -------------------------
        // 0) Preconditions & config
        // -------------------------
        // Ensure we fail fast on unexpected errors
        def originalBranchOut = new ByteArrayOutputStream()
        def revRes = project.exec {
            commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
            standardOutput = originalBranchOut
            ignoreExitValue = false
        }
        def originalBranch = originalBranchOut.toString().trim()
        println "Current branch: ${originalBranch}"

        // Get current HEAD SHA (source of truth for versions.json)
        def headShaOut = new ByteArrayOutputStream()
        project.exec {
            commandLine 'git', 'rev-parse', '--verify', 'HEAD'
            standardOutput = headShaOut
            ignoreExitValue = false
        }
        def sourceSha = headShaOut.toString().trim()
        println "Using source commit (HEAD): ${sourceSha}"

        // -------------------------
        // 1) (Your logic) Generate or update versions.json
        //    Replace the placeholder below with your code that actually writes the file.
        // -------------------------
        println "Writing versions.json..."
        // Example placeholder (replace with your actual generation):
        // new File(project.projectDir, "versions.json").text = generatedJsonContent
        println "versions.json written."

        // -------------------------
        // 2) Stage & commit changes (allow no-op commit)
        // -------------------------
        println "Staging versions.json..."
        def addRes = project.exec {
            commandLine 'git', 'add', 'versions.json'
            ignoreExitValue = true
        }
        if (addRes.exitValue != 0) {
            throw new GradleException("Failed to stage versions.json (git add exit ${addRes.exitValue})")
        }

        println "Committing changes (if any)..."
        def commitRes = project.exec {
            commandLine 'git', 'commit', '-m', "chore: update versions.json [skip hooks]"
            ignoreExitValue = true
        }
        if (commitRes.exitValue == 0) {
            println "Commit created for versions.json."
            // update sourceSha to point to the newly created commit
            def newHeadOut = new ByteArrayOutputStream()
            project.exec {
                commandLine 'git', 'rev-parse', '--verify', 'HEAD'
                standardOutput = newHeadOut
                ignoreExitValue = false
            }
            sourceSha = newHeadOut.toString().trim()
            println "Updated source commit (HEAD): ${sourceSha}"
        } else {
            println "No new commit created (git commit exit ${commitRes.exitValue}) — using existing HEAD ${sourceSha}."
        }

        // -------------------------
        // 3) Get list of remote branches on origin (with their SHAs)
        // -------------------------
        println "Querying remote branches on 'origin'..."
        def remoteOut = new ByteArrayOutputStream()
        def lsRes = project.exec {
            commandLine 'git', 'ls-remote', '--heads', 'origin'
            standardOutput = remoteOut
            ignoreExitValue = true
        }
        if (lsRes.exitValue != 0) {
            throw new GradleException("Failed to list remote branches on origin (git ls-remote exit ${lsRes.exitValue})")
        }

        def remoteLines = remoteOut.toString().readLines().findAll { it.trim() }
        if (remoteLines.isEmpty()) {
            println "No remote branches found on origin — nothing to sync."
            return
        }

        // Build map: branchName -> remoteSha
        def remoteMap = [:] as Map<String, String>
        remoteLines.each { line ->
            def parts = line.split()
            if (parts.length >= 2) {
                def sha = parts[0]
                def ref = parts[1]
                def branch = ref.replace('refs/heads/', '')
                remoteMap[branch] = sha
            }
        }

        println "Found ${remoteMap.size()} remote branch(es) on origin."

        // -------------------------
        // 4) For each remote branch: create temp branch from origin/<branch>,
        //    copy versions.json from sourceSha, commit if changed, push back to origin/<branch>.
        //    Always return to original branch at the end, and clean up temp branch.
        // -------------------------
        remoteMap.each { branch, remoteSha ->
            println "----"
            println "Processing remote branch: ${branch}"

            // create a safe temporary branch name
            def safeBranchName = branch.replaceAll(/[^A-Za-z0-9_.-]/, '_')
            def tmpBranch = "tmp-sync-${safeBranchName}-${System.currentTimeMillis()}"

            try {
                // fetch latest for the specific branch to be safe
                println "Fetching origin/${branch}..."
                def fetchRes = project.exec {
                    commandLine 'git', 'fetch', 'origin', branch + ":" + "refs/remotes/origin/${branch}"
                    ignoreExitValue = true
                }
                if (fetchRes.exitValue != 0) {
                    throw new GradleException("Failed to fetch origin/${branch} (exit ${fetchRes.exitValue})")
                }

                // create and checkout the temp branch from origin/<branch>
                println "Checking out temporary branch '${tmpBranch}' from origin/${branch}..."
                def checkoutRes = project.exec {
                    commandLine 'git', 'checkout', '-b', tmpBranch, "origin/${branch}"
                    ignoreExitValue = true
                }
                if (checkoutRes.exitValue != 0) {
                    throw new GradleException("Failed to create temporary branch ${tmpBranch} from origin/${branch} (git checkout exit ${checkoutRes.exitValue})")
                }

                // Now overwrite versions.json in the temp branch with the version from sourceSha
                println "Copying versions.json from ${sourceSha} into ${tmpBranch}..."
                def checkoutFileRes = project.exec {
                    commandLine 'git', 'checkout', sourceSha, '--', 'versions.json'
                    ignoreExitValue = true
                }
                if (checkoutFileRes.exitValue != 0) {
                    // If checkout of file fails (e.g. file missing in sourceSha), skip this branch
                    println "Warning: failed to checkout versions.json from ${sourceSha} for branch ${branch} (exit ${checkoutFileRes.exitValue}) — skipping."
                    // cleanup: checkout original branch and delete temp
                    project.exec { commandLine 'git', 'checkout', originalBranch; ignoreExitValue = true }
                    project.exec { commandLine 'git', 'branch', '-D', tmpBranch; ignoreExitValue = true }
                    return
                }

                // Check if there are changes to commit (i.e. file actually changed)
                def statusOut = new ByteArrayOutputStream()
                project.exec {
                    commandLine 'git', 'status', '--porcelain', 'versions.json'
                    standardOutput = statusOut
                    ignoreExitValue = true
                }
                def statusStr = statusOut.toString().trim()
                if (!statusStr) {
                    // No changes -> nothing to commit or push
                    println "No change in versions.json for origin/${branch} — skipping push."
                    // cleanup: checkout original branch and delete temp
                    project.exec { commandLine 'git', 'checkout', originalBranch; ignoreExitValue = true }
                    project.exec { commandLine 'git', 'branch', '-D', tmpBranch; ignoreExitValue = true }
                    return
                }

                // Stage and commit the updated versions.json on the temp branch
                println "Staging & committing versions.json on ${tmpBranch}..."
                def addTmp = project.exec {
                    commandLine 'git', 'add', 'versions.json'
                    ignoreExitValue = true
                }
                if (addTmp.exitValue != 0) {
                    throw new GradleException("Failed to stage versions.json on ${tmpBranch} (git add exit ${addTmp.exitValue})")
                }

                def commitMsg = "chore: sync versions.json from ${sourceSha} to ${branch} [skip hooks]"
                def commitTmp = project.exec {
                    commandLine 'git', 'commit', '-m', commitMsg
                    ignoreExitValue = true
                }
                if (commitTmp.exitValue != 0) {
                    throw new GradleException("Failed to commit versions.json on ${tmpBranch} (git commit exit ${commitTmp.exitValue})")
                }
                println "Committed versions.json on ${tmpBranch}."

                // Push the new commit to origin/<branch> (should be fast-forward since tmpBranch started at origin/<branch>)
                println "Pushing updated versions.json to origin/${branch}..."
                def pushRes = project.exec {
                    commandLine 'git', 'push', 'origin', "HEAD:${branch}"
                    ignoreExitValue = true
                }
                if (pushRes.exitValue != 0) {
                    throw new GradleException("Failed to push updated versions.json to origin/${branch} (git push exit ${pushRes.exitValue})")
                }
                println "Successfully pushed versions.json to origin/${branch}."

                // cleanup: checkout original branch and delete temp branch
                project.exec { commandLine 'git', 'checkout', originalBranch; ignoreExitValue = true }
                project.exec { commandLine 'git', 'branch', '-D', tmpBranch; ignoreExitValue = true }
                println "Cleaned up temporary branch ${tmpBranch}."
            } catch (Exception e) {
                // Attempt to restore original branch and delete temp branch if exists, then rethrow
                println "Error while processing branch ${branch}: ${e.message}"
                println "Attempting to restore original branch ${originalBranch} and remove temporary branch ${tmpBranch}."
                project.exec { commandLine 'git', 'checkout', originalBranch; ignoreExitValue = true }
                project.exec { commandLine 'git', 'branch', '-D', tmpBranch; ignoreExitValue = true }
                throw e
            }
        }

        println "All remote branches processed. versions.json synchronized where needed without rewriting remote history."
    }
}
