apply plugin: libs.plugins.shadow.get().pluginId

evaluationDependsOn(':common')

def loomPlatform = project.property('loom.platform')

sourceSets.main.resources.srcDirs = [
        'src/main/resources', 'src/main/generated',
        getRootProject().file("common/src/main/resources")
]

configurations {
    common
    shadowCommon
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    create("development${loomPlatform.capitalize()}") {
        extendsFrom common
    }
}

architectury {
    platformSetupLoomIde()

    if (loomPlatform == 'fabric') fabric()
    else if (loomPlatform == 'forge') forge()
    else if (loomPlatform == 'quilt') loader(loomPlatform)
    else throw new GradleException("Unknown 'loom.platform' value: ${loomPlatform} for project: '${project.name}' ('${project.path}')")
}

loom {
    if (loomPlatform == 'forge') {
        forge {
            if (accessWidenerFile.exists()) {
                convertAccessWideners = true
                extraAccessWideners.add accessWidenerFile.name
            }

            if (file("src/main/resources/${MOD_ID}.mixins.json").exists()) {
                mixinConfig "${MOD_ID}.mixins.json"
            }

            if (getRootProject().file("common/src/main/resources/${MOD_ID}-common.mixins.json").exists()) {
                mixinConfig "${MOD_ID}-common.mixins.json"
            }

            dataGen {
                mod "${MOD_ID}"
            }
        }
    }
}

dependencies {
    if (loomPlatform == 'fabric') {
        modImplementation(libs.fabric.loader)
        modApi(libs.fabric.api)

        modImplementation(libs.patchouli.fabric)
        modImplementation(libs.forge.config.api.port)
    } else if (loomPlatform == 'forge') {
        forge(libs.forge)

        modImplementation(libs.patchouli)
    } else if (loomPlatform == 'quilt') {
        modImplementation(libs.quilt.loader)
        modApi(libs.quilt.stdlib)
        modApi(libs.quilted.fabric.api)

        modImplementation(libs.patchouli.fabric)
        modImplementation(libs.forge.config.api.port)
    }

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowCommon(project(path: ':common', configuration: "transformProduction${loomPlatform.capitalize()}")) { transitive false }
}

shadowJar {
    exclude 'architectury.common.json'
    configurations = [project.configurations.shadowCommon]
    classifier 'dev-shadow'
}

remapJar {
    if (loomPlatform == 'fabric' || loomPlatform == 'quilt') {
        injectAccessWidener = true
    }

    input.set shadowJar.archiveFile
    dependsOn shadowJar
    classifier null
}

jar {
    classifier 'dev'
}

sourcesJar {
    def commonSources = project(':common').sourcesJar
    dependsOn commonSources
    from commonSources.archiveFile.map { zipTree(it) }
}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}

idea.module {
    excludeDirs += [
            file('.gradle'),
            file('build'),
            file('run')
    ]
}
